1、缓存热点Key、大Value
2、缓存一致性问题
3、redis和memcached的区别
4、
5、
6、
7、
8、







---------------------------------------------------------------------------------------------------------------------
缓存热点Key、大Value 


缓存热点Key：瞬间大量请求，导致缓存集群（Redis、Memcached）存储该热点Key的机器宕机
1、基于大数据领域的流式计算技术来进行实时数据访问次数的统计，比如 Storm、Spark Streaming、Flink 或者根据自己的业务还有经验值来自己实现的业务逻辑判定热点数据
2、判定热点数据后，可以把热点数据信息存储到Zookeeper，然后通知所有的应用节点，应用热点缓存自动加载为 JVM 本地缓存（Ehcache、Hashmap等），
3、限流熔断保护，可以作用在后端应用或者缓存集群
总结：应用先从本地缓存-->分布式缓存集群-->数据库，通过zookeeper通知应用加载热点缓存到本地缓存




---------------------------------------------------------------------------------------------------------------------
https://www.cnblogs.com/axtkdd/p/9760786.html
https://www.cnblogs.com/duyinqiang/p/5696253.html
https://blog.csdn.net/justinsause/article/details/51063631



缓存一致性问题：
更新缓存还是淘汰缓存？
更新缓存：先写数据库还是先写缓存？


更新缓存的优点：缓存不会增加一次miss，命中率更高，更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率
淘汰缓存的优点：简单，如果数据操作复杂，淘汰缓存，并且带来的副作用只是增加了一次cache miss



先淘汰缓存再写数据库：
问题：大并发会有缓存击穿 或者 大并发有脏数据
解决：同一份数据库操作串行化（服务、数据库连接根据参数都路由到同一个）

先写数据库再更新缓存：
问题：存在一定时间的不一致性，最终一致性
解决：异步更新，消息总线esb更新等
如果数据库是主从的，主写从读，就要么数据库主从强一致性，或者主写后要等待从写成功如500ms之后再异步更新

强一致性：必然就是全部更新完才能读，导致延迟或者服务不可用



由于数据库层面的读写并发，引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了），可能通过两个小的改动解决：
（1）修改服务Service连接池，id取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上
（2）修改数据库DB连接池，id取模选取DB连接，能够保证同一个数据的读写在数据库层面是串行的




---------------------------------------------------------------------------------------------------------------------

redis和memcached的区别：
1、持久化
2、数据类型redis多种，memcached比较少
3、负载均衡：memcached是在客户端，redis负载均衡逻辑是在服务端，返回重定向
4、高可用？

redis持久化方式：aof追加操作指令，对文件进行优化和合并、rdb全量备份



---------------------------------------------------------------------------------------------------------------------
缓存的作用和分类

缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。
在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘IO的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！


缓存在很多系统和架构中都用广泛的应用,例如：
CPU缓存
操作系统缓存
HTTP缓存
数据库缓存
静态文件缓存
本地缓存
分布式缓存


缓存总体可分为两种 集中式缓存 和 分布式缓存
“集中式缓存"与"分布式缓存"的区别其实就在于“集中”与"非集中"的概念，其对象可能是服务器、内存条、硬盘等。比如：
1.服务器版本：
缓存集中在一台服务器上，为集中式缓存。
缓存分散在不同的服务器上，为分布式缓存。

2.内存条版本：
缓存集中在一台服务器的一条内存条上，为集中式缓存。
缓存分散在一台服务器的不同内存条上，为分布式缓存。

3.硬盘版本：
缓存集中在一台服务器的一个硬盘上，为集中式缓存。
缓存分散在一台服务器的不同硬盘上，为分布式缓存。




---------------------------------------------------------------------------------------------------------------------



