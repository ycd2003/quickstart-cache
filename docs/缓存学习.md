1、缓存热点Key、大Value
2、缓存一致性问题







---------------------------------------------------------------------------------------------------------------------
缓存热点Key、大Value 


缓存热点Key：瞬间大量请求，导致缓存集群（Redis、Memcached）存储该热点Key的机器宕机
1、基于大数据领域的流式计算技术来进行实时数据访问次数的统计，比如 Storm、Spark Streaming、Flink 或者根据自己的业务还有经验值来自己实现的业务逻辑判定热点数据
2、判定热点数据后，可以把热点数据信息存储到Zookeeper，然后通知所有的应用节点，应用热点缓存自动加载为 JVM 本地缓存（Ehcache、Hashmap等），
3、限流熔断保护，可以作用在后端应用或者缓存集群
总结：应用先从本地缓存-->分布式缓存集群-->数据库，通过zookeeper通知应用加载热点缓存到本地缓存




---------------------------------------------------------------------------------------------------------------------
https://www.cnblogs.com/axtkdd/p/9760786.html
https://www.cnblogs.com/duyinqiang/p/5696253.html
https://blog.csdn.net/justinsause/article/details/51063631



缓存一致性问题：
更新缓存还是淘汰缓存？
更新缓存：先写数据库还是先写缓存？


更新缓存的优点：缓存不会增加一次miss，命中率更高，更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率
淘汰缓存的优点：简单，如果数据操作复杂，淘汰缓存，并且带来的副作用只是增加了一次cache miss



先淘汰缓存再写数据库：
问题：大并发会有缓存击穿 或者 大并发有脏数据
解决：同一份数据库操作串行化（服务、数据库连接根据参数都路由到同一个）

先写数据库再更新缓存：
问题：存在一定时间的不一致性，最终一致性
解决：异步更新，消息总线esb更新等
如果数据库是主从的，主写从读，就要么数据库主从强一致性，或者主写后要等待从写成功如500ms之后再异步更新

强一致性：必然就是全部更新完才能读，导致延迟或者服务不可用



由于数据库层面的读写并发，引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了），可能通过两个小的改动解决：
（1）修改服务Service连接池，id取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上
（2）修改数据库DB连接池，id取模选取DB连接，能够保证同一个数据的读写在数据库层面是串行的




---------------------------------------------------------------------------------------------------------------------


